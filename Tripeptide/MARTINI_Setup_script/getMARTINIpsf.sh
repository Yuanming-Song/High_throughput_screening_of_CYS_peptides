#!/bin/bash
# Step 1: Define the input top file
top_dir="./"
# Parse options
while getopts ":b:" opt; do
  case $opt in
    b)
      top_basename="$OPTARG"
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
      exit 1
      ;;
  esac
done



# Check if the required -base argument is set
if [ -z "$top_basename" ]; then
  echo "Error: -b option is required for the basename of the top file."
  exit 1
fi

outputlog="getPSF_$top_basename.log"
exec >$outputlog 2>&1


# Print root name
echo "Root name (PreFix) is: $top_basename"


#define a print atoms section function
# Function to print a formatted atom line
print_atom_line() {
    local atom_index=$1
    local segname=$2
    local resid=$3
    local resname=$4
    local atom_name=$5
    local atom_type=$6
    local charge=0.0
    local mass=12.000
    local psf_file=$7
    # Use only the first 4 characters of segname
    segname=$(echo "$segname" | cut -c 1-4)

    # Print formatted line to PSF file
    printf "%8d %-4s %4d %-4s %-4s %-4s %10.6f %10.4f\n" \
        "$atom_index" "$segname" "$resid" "$resname" "$atom_name" "$atom_type" "$charge" "$mass" \
        >>"$psf_file"
}

# Function to transform bond lines
# Function to transform bond lines
transform_bond_lines() {
    local bond_lines=("${!1}") # Reference to the array passed as argument
    local resid="$2"           # Residue number
    local total_atoms="$3"     # Total number of atoms per residue
    local tot_index="$4"       # Total index for offset

    local transformed_lines=() # Array to store transformed lines

    # Loop through each bond line
    for bond in "${bond_lines[@]}"; do
        # Extract the columns
        first_column=$(echo "$bond" | awk '{print $1}')
        second_column=$(echo "$bond" | awk '{print $2}')

        # Calculate the new values
        new_first=$((first_column + (resid - 1) * total_atoms + tot_index))
        new_second=$((second_column + (resid - 1) * total_atoms + tot_index))

        # Format the new bond line
        formatted_line=$(printf "%8d%8d\n" "$new_first" "$new_second")

        # Add to the array
        transformed_lines+=("$formatted_line")
    done

    # Return the transformed lines array
    echo "${transformed_lines[@]}"
}

print_bond_line() {
    local transformed_bonds_lines=$1

    local psf_file=$2

}

top_file="$top_dir/$top_basename.top"
#FFssFF_Acid_Lattice_25mM_FSSF.top"
atoms_output_file="atoms_$top_basename.psf"
bonds_output_file="bonds_$top_basename.psf"
combined_output_file="combined_$top_basename.psf"
rm $atoms_output_file $bonds_output_file
# Print PSF header to file
cat <<EOT >"$atoms_output_file"
PSF

       1 !NTITLE
 REMARKS Generated by script

PLACEHOLDER_NATOM_LINE
EOT
# Define the output file
# Print bond section header to the file
cat <<EOT >>"$bonds_output_file"

PLACEHOLDER_NBOND_LINE
EOT
# Step 2: Read the top file line by line until "#include" and "itp"
pathnames=() # Array to store pathnames
atom_index=0
total_bonds_count=0
while IFS= read -r line; do
    if [[ "$line" == *"#include"* && "$line" == *"itp"* ]]; then
        # Extract the full pathname enclosed in double quotes
        pathname=$(echo "$line" | grep -o '"[^"]*"')
        # Remove the double quotes from the pathname
        pathname=$(sed -e 's/^"//' -e 's/"$//' <<<"$pathname")
        pathnames+=("$pathname")
    elif [[ "$line" == *"[ molecules ]"* ]]; then
        # Move to step 3 once we reach the "molecules" section
        echo "Reached 'molecules' section."
        break
    fi
done <"$top_file"

# Step 3: Extract and print each <segname> <molnum> pair in the "molecules" section
echo "Extracting <segname> <molnum> pairs:"
segname_pairs=()

# Print all recorded pathnames
echo "All itp file pathnames found:"
printf '%s\n' "${pathnames[@]}"

while IFS= read -r line; do
    echo $line
    if [[ "$line" =~ ^[[:space:]]*([^[:space:]]+)[[:space:]]+([[:digit:]]+)$ ]]; then
        segname="${BASH_REMATCH[1]}"
        molnum="${BASH_REMATCH[2]}"
        segname_pairs+=("$segname $molnum")
        echo "$segname $molnum"
    fi
done < <(awk '/^\s*\[ molecules \]/{flag=1; next} /^\s*\[/{flag=0} flag' "$top_file")
# Step 4: Search for [ moleculetype ] section containing <segname> in each itp file
for pair in "${segname_pairs[@]}"; do
    segname=$(echo "$pair" | awk '{print $1}')
    molnum=$(echo "$pair" | awk '{print $2}')
    #molnum=5
    echo "Processing segname: $segname, molnum: $molnum"

    for itp_file in "${pathnames[@]}"; do

        # Read the file line by line
        # while IFS= read -r line; do
        #     # Check for [ moleculetype ] section header
        #     if [[ "$line" =~ ^[[:space:]]*\[[[:space:]]*moleculetype[[:space:]]*\] ]]; then
        #         section_header_found=true
        #         section="[ moleculetype ]"$'\n'
        #         continue
        #     fi

        #     # Check if we are within the [ moleculetype ] section
        #     if [[ "$section_header_found" = true ]]; then
        #         # Skip empty lines and comments starting with ;
        #         if [[ -z "$line" || "$line" =~ ^[[:space:]]*';' ]]; then
        #             continue
        #         fi

        #         # Check for the exact match of segname in the first column
        #         first_column=$(echo "$line" | awk '{print $1}')
        #         if [[ "$first_column" = "$segname" ]]; then
        #             # Print the section if segname is found
        #             echo "Found moleculetype section for $segname in $itp_file:"
        #             echo "$section$line"$'\n'
        #             found_section=true
        #             break
        #         fi
        #     fi

        #     # Check for the start of a new section (line starts with [)
        #     if [[ "$line" =~ ^\[ ]]; then
        #         # Exit the loop if a new section is found
        #         if [[ "$section_header_found" = true ]]; then
        #             break
        #         fi
        #     fi

        #     # Accumulate lines into the section
        #     if [[ "$section_header_found" = true ]]; then
        #         section="$section$line"$'\n'
        #     fi
        # done < "$itp_file"

        # Step 5: Process atoms section
        echo "Processing file: $itp_file"
        found_section=false
        section_header_found=false
        section=""
        atoms_lines=() # Array to store atoms section lines
        bonds_lines=()
        found_moleculetype_section=false
        print_atoms_section=false
        print_bonds_section=false
        found_bonds_section=false
        found_atoms_section=false

        while IFS= read -r line; do
            # Check for [ moleculetype ] section header
            if [[ "$line" =~ ^[[:space:]]*\[[[:space:]]*moleculetype[[:space:]]*\] ]]; then
                found_moleculetype_section=true
                echo "found_moleculetype_section=true"
                continue
            fi

            # Check if we are within the [ moleculetype ] section
            if [[ "$found_moleculetype_section" = true ]]; then
                # Check for the exact match of segname in the first column
                first_column=$(echo "$line" | awk '{print $1}')
                if [[ "$first_column" = "$segname" ]]; then
                    echo "Found moleculetype section for $segname in $itp_file:"
                    echo "$line"
                    found_moleculetype_section=false # Reset flag after printing section
                    echo "found_moleculetype_section=false"
                    print_atoms_section=true # Set flag to start printing atoms section
                    echo "print_atoms_section=true"
                    print_bonds_section=true # Set flag to start printing atoms section
                    echo "print_bonds_section=true"
                fi
            fi

            # Print atoms section content if found
            if [[ "$print_atoms_section" = true && "$line" =~ ^[[:space:]]*\[[[:space:]]*atoms[[:space:]]*\] ]]; then
                if [[ "$found_atoms_section" = false ]]; then
                    echo "Atoms section for $segname in $itp_file:"
                    found_atoms_section=true
                    echo "found_atoms_section=true"
                    continue
                fi
                continue # Skip the section header line
            fi
            if [[ "$found_atoms_section" = true && "$line" =~ ^\[ ]]; then
                echo "Atoms section over at: $line"
                found_atoms_section=false
            fi
            # Print atoms section content if found
            if [[ "$found_atoms_section" = true && ! "$line" =~ ^\[ && "$first_column" = "$segname" ]]; then

                # Skip empty lines and comments starting with ;
                if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*';' ]]; then
                    atoms_lines+=("$line")

                fi
            fi

            #Print bonds section content if found
            if [[ "$print_bonds_section" = true && "$line" =~ ^[[:space:]]*\[[[:space:]]*bonds[[:space:]]*\] ]]; then
                if [[ "$found_bonds_section" = false ]]; then
                    echo "bonds section for $segname in $itp_file:"
                    found_bonds_section=true
                    print_bonds_section=true # Set flag to start printing bonds section
                fi
                continue # Skip the section header line
            fi

            if [[ "$found_bonds_section" = true && "$line" =~ ^\[ ]]; then
                if [[ "$line" =~ ^[[:space:]]*\[[[:space:]]*constraints[[:space:]]*\] ]]; then
                    echo "include constraints as bonds"
                    continue
                else
                    echo "Bonds section over at: $line"
                    found_bonds_section=false
                fi
            fi

            # Print bonds section content if found
            if [[ "$found_bonds_section" = true && ! "$line" =~ ^\[ && "$first_column" = "$segname" ]]; then
                # Skip empty lines and comments starting with ;
                if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*';' ]]; then
                    bonds_lines+=("$(echo "$line" | awk '{print $1, $2}')")
                fi
            fi
        done <"$itp_file"

        # Step 6: Process atoms lines and convert to PSF format
        total_atoms=${#atoms_lines[@]} # Total number of atoms lines
        echo "Total atoms lines for $segname in $itp_file: $total_atoms"
        tot_index=$atom_index
        printf '%s\n' "${atoms_lines[@]}"

        if [[ "$print_bonds_section" = true ]]; then
            mapfile -t bonds_lines < <(printf '%s\n' "${bonds_lines[@]}" | grep '^[0-9]')
            total_bonds=${#bonds_lines[@]} # Total number of atoms lines
            echo "Total bonds lines for $segname in $itp_file: $total_bonds"
            # Redefine bonds_lines with only numeric lines
            printf '%s\n' "${bonds_lines[@]}"

        fi

        for ((resid = 1; resid <= molnum; resid++)); do
            for ((index = 0; index < total_atoms; index++)); do
                line="${atoms_lines[$index]}"
                columns=($line)
                atom_index=$((index + 1 + (resid - 1) * total_atoms + tot_index))

                atom_name="${columns[1]}"
                case "$atom_name" in
                Q) atom_name="O" ;;
                SC5) atom_name="C" ;;
                P5) atom_name="N" ;;
                SP5) atom_name="N" ;;
                C5) atom_name="S" ;;
                SC5) atom_name="N" ;;
                P4) atom_name="OH2" ;;
                esac

                resname="${columns[3]}"
                atom_type="${columns[4]}"

                # Print PSF compatible line
                print_atom_line "$atom_index" "$segname" "$resid" "$resname" "$atom_name" "$atom_type" "$atoms_output_file"
            done
            if [[ "$print_bonds_section" = true ]]; then
                total_bonds_count=$(($total_bonds_count + $total_bonds))

                transformed_bonds_lines=$(transform_bond_lines bonds_lines[@] "$resid" "$total_atoms" "$tot_index")
                # Read the last line of the file
                last_line=$(tail -n 1 $bonds_output_file)

                # Count the number of columns
                num_columns=$(echo "$last_line" | awk '{print NF}')

                # Check if all columns are numbers
                all_numbers=true
                for item in $last_line; do
                    if ! [[ $item =~ ^[0-9]+$ ]]; then
                        all_numbers=false
                        break
                    fi
                done

                # Determine initial count
                if [ $all_numbers = true ] && [ $num_columns -eq 8 ]; then
                    count=0
                elif [ $all_numbers = true ]; then
                    count=$num_columns
                else
                    count=0
                fi

                IFS=' ' read -r -a bonds_array <<<"$transformed_bonds_lines"

                # Open the output file in append mode
                exec 3>>$bonds_output_file

                # If the last line is incomplete and valid, start filling it
                if [ $count -gt 0 ]; then
                    for bond in "${bonds_array[@]}"; do
                        printf "%8d" "$bond" >&3
                        count=$((count + 1))
                        if [ $count -eq 8 ]; then
                            echo "" >&3
                            count=0
                        fi
                    done
                else
                    # Print 8 columns per line to the output file
                    for bond in "${bonds_array[@]}"; do
                        printf "%8d" "$bond" >&3
                        count=$((count + 1))
                        if [ $count -eq 8 ]; then
                            echo "" >&3
                            count=0
                        fi
                    done
                fi

                # Close the file descriptor
                exec 3>&-
            fi
        done
        tot_index=$atom_index

    done
done
sed -i "s/PLACEHOLDER_NATOM_LINE/$(printf '%8d !NATOM' "$tot_index")/" "$atoms_output_file"
sed -i "s/PLACEHOLDER_NBOND_LINE/$(printf '%8d !NBOND' "$total_bonds_count")/" "$bonds_output_file"
# Record how many lines in total
#loop through 1 to molnum, set varible to to resid

#convert each line in atoms section to psf file compatble format
#index is first column +  (resid - 1) * total atoms line
#atom names depends on what second column in itp file has, O for Q, C for SC5, N for P, S for C5, OH2, OH2 for W
#resid in psf file is current resid
#atom type matches the 5th column in itp file
#resname is the fourth column
#record all those psf compaitble lines in a first section psf file
echo "Combining"
cat "$atoms_output_file" "$bonds_output_file" >"$combined_output_file"
echo "Done"